https://www.acmicpc.net/problem/23843

# ⚡ [백준 23843] 콘센트 (Greedy & Priority Queue)

## 1. 💡 핵심 직관 (The Kick) : "테트리스 전략"

이 문제는 단순한 구현이 아니라 **"빈 공간 메우기(Gap Filling)"** 싸움입니다.

* **왜 큰 것부터(`Desc Sort`) 넣어야 하는가?**
* **작은 돌 먼저:** 바닥을 평평하게 다져놔도, 마지막에 **거대한 바위(긴 시간)**가 떨어지면 한쪽만 높이가 폭발합니다. (밸런스 붕괴  전체 시간 증가)
* **큰 돌 먼저:** 초반에 큰 돌을 배치하여 **"지붕(최대 높이)"**을 만들고, 옆에 생긴 **거대한 빈 공간(Gap)**을 작은 돌들로 채워 넣으면 전체 높이를 평평하게 유지할 수 있습니다.


* **비유:** **OS 스케줄러(Load Balancing)**.
* 가장 무거운 작업(Task)을 먼저 처리해야, 코어(Core)들이 노는 시간(Idle Time) 없이 동시에 일을 마칠 수 있습니다.



## 2. 🛠️ 알고리즘 설계

1. **정렬:** 입력받은 시간을 **내림차순** 정렬. ()
2. **자료구조:** **최소 힙(Min-Heap)**을 사용하여 콘센트 개의 상태 관리.
* 항상 **"가장 빨리 끝나는 콘센트(최솟값)"**를 $O(1)$만에 찾아야 하기 때문.


3. **로직:**
* 처음 개의 기기는 바로 콘센트에 꽂음 (힙 초기화).
* 남은 기기들은 `heappop()`으로 가장 빈 콘센트를 꺼내서 충전 시간을 더하고 다시 `heappush()`.



## 3. ⏱️ 시간 복잡도 분석 (Deep Dive)

전체 복잡도는 ****입니다.

* **1단계: 정렬 (Sorting)**
* 비용: ****
* 가장 비용이 큰 작업이지만, 그리디 전략을 위해 필수.


* **2단계: 힙 연산 (Heap Operations)**
* 비용: **** (중요!)
* 우리는 힙의 크기를 항상 **콘센트 개수()**로 유지합니다.
* 따라서 힙에 넣고 빼는 비용은 이 아니라 ****입니다.
* 보통 이므로, 이는 거의 선형 시간()에 가깝게 처리됩니다.


* **3단계: 최댓값 찾기 (`max`)**
* 비용: ****
* 힙 구조를 깨지 않고 리스트를 한 번 스캔(Scan)만 하므로 매우 빠름.



## 4. 🙋‍♂️ Q&A (내가 했던 고민들)

**Q1. 힙은 큐(Queue)인가?**

* 아니다. 큐는 **선착순(FIFO)**이지만, 힙은 **능력순(Priority)**이다.
* 힙은 **"느슨한 정렬 상태"**를 유지하는 트리 구조이며, 우선순위 큐를 구현하는 최고의 도구다.

**Q2. 왜 `N - M`번만 반복하는가?**

* 최적화를 위해 처음 개의 기기는 힙에 바로 꽂고 시작한다. (0을 넣고 빼는 불필요한 연산 제거)
* 따라서 남은 개의 기기에 대해서만 `pop` & `push`를 수행하면 된다.

**Q3. `max(heap)`을 하면 힙이 망가지거나 느리지 않나?**

* `max()` 함수는 힙 내부 구조(트리)를 건드리지 않고, 메모리에 나열된 리스트를 단순히 **읽기만(Read Only)** 한다.
* 따라서 힙은 유지되며, 시간 복잡도는 $O(M)$으로 아주 효율적이다.

## 5. 💻 최종 코드 (Python)

```python
import sys
import heapq

input = sys.stdin.readline

def solve():
    N, M = map(int, input().split())
    times = list(map(int, input().split()))

    # [핵심] 큰 작업부터 처리해야 빈 공간을 효율적으로 채움
    times.sort(reverse=True)

    # [예외 처리] 기기가 콘센트보다 적으면, 가장 긴 시간이 정답
    if N <= M:
        print(max(times) if N > 0 else 0)
        return

    # [최적화] 힙의 크기를 M개로 유지 (초기 M개 삽입)
    outlets = []
    for i in range(M):
        heapq.heappush(outlets, times[i])

    # 남은 기기 처리 (Load Balancing)
    for i in range(M, N):
        min_val = heapq.heappop(outlets)
        heapq.heappush(outlets, min_val + times[i])

    print(max(outlets))

solve()

```