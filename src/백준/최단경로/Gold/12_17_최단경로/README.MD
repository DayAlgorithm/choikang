[문제 링크](https://www.acmicpc.net/problem/1753)

# 1753번: 최단경로

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1 초 | 256 MB | 255183 | 81404 | 42217 | 27.096% |

-----

## 문제

방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.

-----

## 입력

첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.

-----

## 출력

첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.

-----

## 예제 입력 1

```
5 6
1
5 1 1
1 2 2
1 3 3
2 3 4
2 4 5
3 4 6
```

## 예제 출력 1

```
0
2
3
7
INF
```

-----

## 💡 이 문제를 풀기 위한 핵심 개념

이 문제는 \*\*"다익스트라 알고리즘 (Dijkstra's Algorithm)"\*\*을 사용하여 풀어야 하는 가장 대표적인 문제입니다.

### 1\. 왜 다익스트라 인가요?

* **문제 유형:** "한 시작점"에서 "다른 모든 정점"까지의 최단 경로를 구해야 합니다. (Single Source Shortest Path)
* **가중치:** 간선에 가중치(비용)가 있습니다. (가중치가 없으면 BFS로 풀 수 있지만, 여기서는 가중치가 있으므로 BFS는 불가능합니다.)
* **가중치 값:** 가중치가 모두 \*\*양수(자연수)\*\*입니다. (음수 가중치가 있다면 벨만-포드 알고리즘을 써야 하지만, 양수만 있으므로 다익스트라가 훨씬 효율적입니다.)

### 2\. 다익스트라 알고리즘의 원리

다익스트라는 **그리디(Greedy) 알고리즘**의 일종입니다.
핵심 아이디어는 **"지금 당장 갈 수 있는 곳 중, 가장 비용이 적게 드는 곳부터 방문한다"** 입니다.

**동작 과정:**

1.  **준비물:**

    * `dist[]` 배열: 시작점에서 각 노드까지 가는 최단 거리를 저장. 처음엔 모두 \*\*무한대(INF)\*\*로 초기화하고, 시작점만 `0`으로 설정합니다.
    * **우선순위 큐 (Priority Queue):** 현재 방문할 수 있는 노드 중 **거리가 가장 짧은 노드**를 빠르게($O(\log N)$) 꺼내기 위해 사용합니다.

2.  **알고리즘 흐름:**

    1.  시작 노드를 우선순위 큐에 넣습니다. (거리 0)
    2.  큐에서 **가장 거리가 짧은 노드**를 꺼냅니다. (현재 노드)
    3.  현재 노드를 거쳐서 주변 노드(이웃)로 가는 거리를 계산합니다.
        * `새로운 거리` = `현재 노드까지의 거리` + `이웃으로 가는 간선 가중치`
    4.  만약 `새로운 거리`가 기존에 알고 있던 `이웃 노드의 거리(dist[이웃])`보다 **짧다면**:
        * `dist[이웃]`을 `새로운 거리`로 갱신(Update)합니다.
        * 갱신된 정보 `(이웃 노드, 새로운 거리)`를 우선순위 큐에 넣습니다.
    5.  큐가 빌 때까지 2\~4번을 반복합니다.

### 3\. 자료구조 선택 (주의사항)

* **인접 리스트 vs 인접 행렬:**
    * 정점(V)이 20,000개입니다. 인접 행렬(`int[20001][20001]`)을 쓰면 메모리가 약 1.6GB가 필요하여 **메모리 초과**가 납니다.
    * 따라서 \*\*인접 리스트 (`ArrayList<ArrayList<Node>>`)\*\*를 사용해야 합니다.
* **우선순위 큐 사용:**
    * 큐에 넣을 때 비용이 적은 것이 먼저 나오도록 정렬 기준(`Comparable` 인터페이스 구현)을 만들어야 합니다.

https://roytravel.tistory.com/340
